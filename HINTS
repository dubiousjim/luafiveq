HINTS
=====

In Lua 5.2, coroutine.running() returns (thread, false) when called from main thread, instead of nil

 * in 5.1.4, load(func, [chunkname="=(load)"]) only accepts functions, which are expected to return string pieces on each call
 * in 5.2.0, it also accepts strings, and accepts an additional mode parameter (defaults to "bt") and env parameter
 * in 5.2.0, package.loadlib(path, "entry") permits entry="*", meaning: only link this library, don't return an entry function
 * patterns in 5.2.0 may contain \0 ( ~~> %z ) and %g

 * in 5.2.0, a __gc element needs to be present in a metatable *before*
   lua_setmetatable

 * the version of newproxy we provide in 5.2.0's fiveglue.so accepts the __gc
   function as a parameter in place of `true`

TODO


PATCHES
=======

FIXME

If you'd like your version of Lua 5.1 to act even more like Lua 5.2, but for
some reason aren't able to upgrade, consider building Lua 5.1 with the following
patches applied:

    Yieldable for loops

    __lt, __le metamethods for diff types

    Tables honor __len

    string.format honors __tostring for %s

    os.exit([exitcode], [lua_close?])
        - the lua application calls lua_close before returning;
          by default, os.exit skips that.

    Custom error object
        - Uncaught error handler in standard Lua interpreter calls tostring()
          on error object.  This ensures that a call stack is displayed even
          for non-string error objects.  It also allows use of the __tostring
          hook for human-readable error messages.

        - Base library error() will set the _WHERE field of any table error
          object to the value of luaL_where().  Uncaught error handler in the
          standard Lua interpreter will use this, so that for custom error
          object the error location is shown in the call stack.  This is a bit
          of a hack and implies that any thrown table should be a unique
          instance of the error (since it will be mutated).  Rather than this
          scheme, the ideal solution would be to have the Lua core manage the
          location separate from the error object.

This last patch is also extremely useful:

    Advanced readline support
        - Completion of keywords and global variable names.
        - Recursive and metatable-aware completion of variable names.
        - Context sensitive delimiter completion.
        - Save/restore of the history to/from a file (LUA_HISTORY env variable).
        - Setting a limit for the size of the history (LUA_HISTSIZE env
          variable).
        - Setting the app name to allow for $if lua ... $endif in ~/.inputrc.




Notes
-----


/*
 * bool lua_getmetatable (lua_State *L, int idx); ~~> true, stack[+1]; or
 * false, stack[unchanged]
 *
 * int luaL_getmetafield (lua_State *L, int idx, const char *field); ~~> true,
 * stack[+1]=field; or false, stack[unchanged]
 */


/*
 * shallowly ensure that stack[idx][field] is a table and push it onto stack
 *   ~~> true, stack[+1] if already existed; or false, stack[+1] if allocated
 */
extern int luaL_getsubtable (lua_State *L, int idx, const char *field);


/*
 * luaL_newmetatable(L, "type"); ~~> true, stack[+1] if allocated; or false,
 * stack[+1]
 *
 * void *luaL_checkudata(L, idx, "type");
 *
 * void luaL_getmetatable(L, "type"); ~~> stack[+1]
 */



/* like luaL_checkudata, but returns NULL instead of error when non-matching */
extern void *luaL_testudata (lua_State *L, int ud, const char *tname);

/* assign registry[tname] as metatable for stack[-1] */
extern void luaL_setmetatable (lua_State *L, const char *tname);



/* <luaconf.h> -- uses <limits>,<stddef> */
/* <lua.h> -- uses luaconf,<stddef>,<stdarg> */
#include <lua.h>
/* <lauxlib.h> -- uses lua,<stddef>,<stdio> */
#include <lauxlib.h>
/* <lualib.h> -- uses lua, provides
 * LUA_FILEHANDLE,LUA_{CO,TAB,IO,OS,STR,MATH,DB,LOAD}LIBNAME, luaopen_foo,
 * luaL_openlibs, lua_assert ~~> nop */


/* void lua_len(L, i) honors __len */
/* int luaL_len(L, i) effectively does luaL_checkint on lua_len(L, i), leaves
 * raw len on stack and returns it converted to int */


